<!DOCTYPE html>
<html>
<head>
  <title>Hearthstone Card Images</title>
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    header {
      margin: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    input[type="text"] {
      text-align: center;
      font-size: 24px;
      width: 25%;
      min-width: 350px;
      border-radius: 10px;
      border: 1px solid #ccc;
      padding: 10px 20px;
      outline: 0;
    }
    input::placeholder {
      color: #ccc;
    }
    .controls, button {
      margin: 20px 0 0 0;
      display: flex;
      align-items: center;
      font-size: 16px;
    }
    .controls > * {
      margin: 0 20px;
    }
    .zoom {
      display: flex;
      align-items: center;
    }
    .zoom > * {
      margin: 0 5px;
    }
    p {
      margin: 0;
      padding: 0;
      color: #555;
    }
    .cards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    img.loading {
      background-image: repeating-linear-gradient(50deg, transparent, transparent 10px, rgba(0, 0, 0, .1) 10px, rgba(0, 0, 0, .1) 20px);
    }
    .cards p {
      margin-top: 80px;
      font-size: 30px;
      max-width: 60%;
      line-height: 170%;
    }
    button {
      background: transparent;
      border: none;
      outline: none;
    }
    a, button {
      color: #862;
      text-decoration: underline;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <a href="https://github.com/schmich/hearthstone-card-images">
    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub">
  </a>
  <div id="app">
    <header>
      <input type="text" ref="q" name="query" v-debounce="750" v-model.lazy="inputQuery" spellcheck="false" :disabled="!loaded" :placeholder="loaded ? 'Search for Hearthstone cards' : 'Loading...'">
      <div class="controls" v-show="cards.length > 0">
        <div class="zoom">
          <p>{{ Math.ceil((height / 395) * 100) }}%</p> <input :disabled="!loaded" type="range" v-model="height" min="1" max="395">
        </div>
        <p>{{ cards.length }} results</p>
        <button @click="clearQuery">Clear</button>
      </div>
    </header>
    <div class="cards">
      <template v-if="cards.length">
        <a v-for="card in cards" :href="card" target="_new">
          <image-loader :src="card" :key="card" :style="{ width: ((height / 395) * 286) + 'px', height: height + 'px' }"></image-loader>
        </a>
      </template>
      <template v-else-if="loaded && !query">
        <p>
          Try <template v-for="(example, i) in examples">
            <a @click.prevent="runQuery" :href="'?q=' + encodeURIComponent(example)">{{ example }}</a><template v-if="i !== examples.length - 1">, </template>
          </template>
        </p>
      </template>
      <template v-else-if="loaded">
        <p>No results.</p>
      </template>
    </div>
  </div>
  <script>
    function debounce(fn, delay) {
      let timeoutId = null;
      return () => {
        clearTimeout(timeoutId);
        let args = arguments;
        timeoutId = setTimeout(() => {
          fn.apply(this, args);
        }, delay);
      };
    }
    function debounceDirective(el, binding) {
      if (binding.value !== binding.oldValue) {
        el.oninput = debounce(_ => {
          el.dispatchEvent(new Event('change'));
        }, +binding.value || 500);
      }
    }
    function queryParameter(location) {
      let params = {};
      location.search.slice(1).split('&').map(p => p.split('=')).forEach(p => params[p[0]] = p[1]);
      return decodeURIComponent(params.q || '');
    }
    const imageLoader = {
      props: ['src'],
      template: '<img :class="{ loading: loading }" @load="loading = false" :src="src"/>',
      data: () => {
        return {
          loading: true
        };
      }
    };
    const App = new Vue({
      el: '#app',
      data: {
        inputQuery: '',
        query: '',
        height: 296,
        cardImages: {},
        loaded: false,
        examples: [
          'dragon', 'pirate', 'mech', 'demon', 'murloc', 'beast', 'totem', 'elemental', 'taunt',
          'divine shield', 'windfury', 'charge', 'stealth' ,'poisonous', 'lifesteal', 'battlecry',
          'deathrattle', 'spell damage', 'overload', 'lifesteal', 'weapon', 'secret', 'combo',
          'discover', 'adapt', 'inspire', 'freeze', 'choose one', 'hero power', 'adjacent', 'draw',
          'random'
        ]
      },
      directives: {
        debounce: debounceDirective
      },
      components: {
        'image-loader': imageLoader
      },
      async mounted() {
        let resp = await Promise.all([
          fetch('https://api.hearthstonejson.com/v1/latest/enUS/cards.json').then(resp => resp.json()),
          fetch('https://raw.githubusercontent.com/schmich/hearthstone-card-images/master/images.json').then(resp => resp.json())
        ]);

        let [cards, images] = resp;

        let dbfIdUrls = {};
        for (let dbfId in images.cards.rel) {
          dbfIdUrls[dbfId] = `${images.config.base}/${images.config.version}/rel/${dbfId}.png`;
        }

        let cardImages = {};
        for (let card of cards) {
          if (!card.name) {
            continue;
          }

          let key = this.normalize((card.name + (card.text || '') + (card.race || '') + (card.type || '')));
          cardImages[key] = cardImages[key] || dbfIdUrls[card.dbfId];
        }

        this.cardImages = cardImages;
        this.inputQuery = queryParameter(window.location) || '',

        window.onpopstate = () => {
          this.query = queryParameter(window.location) || '';
          this.$refs.q.value = this.query;
        };

        this.loaded = true;
        this.focusQuery();
      },
      methods: {
        normalize(s) {
          return s.toLowerCase().replace(/[^a-z]/g, '');
        },
        runQuery(el) {
          this.inputQuery = el.target.innerText;
          this.focusQuery();
        },
        clearQuery() {
          this.inputQuery = '';
          this.focusQuery();
        },
        focusQuery() {
          Vue.nextTick(() => {
            this.$refs.q.focus();
            this.$refs.q.setSelectionRange(0, input.value.length);
          });
        }
      },
      computed: {
        cards() {
          let show = [];
          let search = this.normalize(this.query);
          if (search.length < 3) {
            return [];
          }

          for (let name in this.cardImages) {
            if (name.indexOf(search) >= 0) {
              let image = this.cardImages[name];
              if (image) {
                show.push(image);
              }
            }
          }

          return show;
        }
      },
      watch: {
        inputQuery(to) {
          this.query = to;
          window.history.pushState('', '', to ? `?q=${encodeURIComponent(to)}` : '/');
        }
      }
    });
  </script>
</body>
</html>

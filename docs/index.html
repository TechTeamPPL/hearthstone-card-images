<!DOCTYPE html>
<html>
<head>
  <title>Hearthstone Card Images</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    header {
      margin: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    input[type="text"] {
      text-align: center;
      font-size: 24px;
      width: 25%;
      min-width: 350px;
      border-radius: 10px;
      border: 1px solid #ccc;
      padding: 10px 20px;
      outline: 0;
    }
    input::placeholder {
      color: #ccc;
    }
    .controls, button {
      margin: 20px 0 0 0;
      display: flex;
      align-items: center;
      font-size: 16px;
    }
    .controls > * {
      margin: 0 20px;
    }
    .zoom {
      display: flex;
      align-items: center;
    }
    .zoom > * {
      margin: 0 5px;
    }
    .zoom p {
      width: 50px;
    }
    p {
      margin: 0;
      padding: 0;
      color: #555;
    }
    .cards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    img.loading {
      background-image: repeating-linear-gradient(50deg, transparent, transparent 10px, rgba(0, 0, 0, .1) 10px, rgba(0, 0, 0, .1) 20px);
    }
    .cards p {
      margin-top: 80px;
      font-size: 30px;
      max-width: 70%;
      line-height: 170%;
    }
    button {
      background: transparent;
      border: none;
      outline: none;
    }
    a, button {
      color: #1776b9;
      text-decoration: none;
      cursor: pointer;
    }
    a:hover, button:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <a href="https://github.com/schmich/hearthstone-card-images">
    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub">
  </a>
  <div id="app">
    <header>
      <input type="text" ref="q" name="query" v-debounce="750" v-model.lazy="query" spellcheck="false" :disabled="!loaded" :placeholder="loaded ? 'Search for Hearthstone cards' : 'Loading...'">
      <div class="controls" v-show="cards.length > 0">
        <div class="zoom">
          <p>{{ Math.ceil((height / 395) * 100) }}%</p> <input :disabled="!loaded" type="range" v-model="height" min="1" max="395">
        </div>
        <p>{{ cards.length }} result{{ cards.length == 1 ? '' : 's' }}</p>
        <button @click="clearQuery">Clear</button>
      </div>
    </header>
    <div class="cards">
      <template v-if="cards.length">
        <a v-for="card in cards" :href="card" target="_new">
          <image-loader :src="card" :key="card" :style="{ width: ((height / 395) * 286) + 'px', height: height + 'px' }"></image-loader>
        </a>
      </template>
      <template v-else-if="loaded && !query">
        <p>
          Try <template v-for="(example, i) in examples">
            <a @click.prevent="runQuery" :href="'?q=' + encodeURIComponent(example)">{{ example }}</a><template v-if="i !== examples.length - 1">, </template>
          </template>
        </p>
      </template>
      <template v-else-if="loaded">
        <p>No results.</p>
      </template>
    </div>
  </div>
  <script>
    function debounce(fn, delay) {
      let timeoutId = null;
      return () => {
        clearTimeout(timeoutId);
        let args = arguments;
        timeoutId = setTimeout(() => {
          fn.apply(this, args);
        }, delay);
      };
    }
    function debounceDirective(el, binding) {
      if (binding.value !== binding.oldValue) {
        el.oninput = debounce(_ => {
          el.dispatchEvent(new Event('change'));
        }, +binding.value || 500);
      }
    }
    function queryParameter(location) {
      let params = {};
      location.search.slice(1).split('&').map(p => p.split('=')).forEach(p => params[p[0]] = p[1]);
      return decodeURIComponent(params.q || '');
    }
    function normalize(s) {
      return s
        .toLowerCase()
        .replace(/<[^>]+?>/g, '')
        .replace(/[^a-z]/g, '');
    }
    const imageLoader = {
      props: ['src'],
      template: '<img :class="{ loading: loading }" @load="loading = false" :src="src"/>',
      data: () => {
        return {
          loading: true
        };
      }
    };
    const App = new Vue({
      el: '#app',
      data: {
        query: '',
        height: 296,
        cardImages: {},
        loaded: false,
        fromLocation: false,
        examples: [
          'dragon', 'pirate', 'mech', 'demon', 'murloc', 'beast', 'totem', 'elemental', 'taunt',
          'divine shield', 'windfury', 'charge', 'stealth' ,'poisonous', 'lifesteal', 'battlecry',
          'deathrattle', 'spell damage', 'overload', 'lifesteal', 'weapon', 'secret', 'combo',
          'discover', 'adapt', 'inspire', 'freeze', 'choose one', 'hero power', 'adjacent', 'draw',
          'deal damage', 'can\'t attack', 'mana crystal', 'random'
        ]
      },
      directives: {
        debounce: debounceDirective
      },
      components: {
        'image-loader': imageLoader
      },
      async mounted() {
        let [cards, images] = await Promise.all([
          fetch('https://api.hearthstonejson.com/v1/latest/enUS/cards.json').then(resp => resp.json()),
          fetch('https://raw.githubusercontent.com/schmich/hearthstone-card-images/master/images.json').then(resp => resp.json())
        ]);

        let dbfIdUrls = {};
        for (let dbfId in images.cards.rel) {
          dbfIdUrls[dbfId] = `${images.config.base}/${images.config.version}/rel/${dbfId}.png`;
        }

        let cardImages = {};
        for (let card of cards) {
          if (!card.name) {
            continue;
          }

          let image = dbfIdUrls[card.dbfId];
          if (image) {
            let key = normalize((card.name + (card.text || '') + (card.race || '') + (card.type || '')));
            cardImages[key] = cardImages[key] || image;
          }
        }

        this.cardImages = cardImages;
        await this.setQueryFromLocation();

        window.onpopstate = () => {
          Vue.nextTick(() => this.setQueryFromLocation());
        };

        this.loaded = true;
        this.focusQuery();
      },
      methods: {
        runQuery(el) {
          this.query = el.target.innerText;
          this.focusQuery();
        },
        clearQuery() {
          this.query = '';
          this.focusQuery();
        },
        async unfocusQuery() {
          await Vue.nextTick(() => {
            let input = this.$refs.q;
            input.setSelectionRange(0, 0);
            input.blur();
          });
        },
        async focusQuery() {
          await Vue.nextTick(() => {
            let input = this.$refs.q;
            input.focus();
            input.setSelectionRange(0, input.value.length);
          });
        },
        async setQueryFromLocation() {
          await this.unfocusQuery();
          this.fromLocation = true;
          this.query = queryParameter(window.location) || '';
          await Vue.nextTick(async () => {
            this.fromLocation = false;
            await this.focusQuery();
          });
        }
      },
      computed: {
        cards() {
          if (this.query.length < 3) {
            return [];
          }

          let show = [];
          let terms = this.query.split(' ').map(t => normalize(t));

          for (let name in this.cardImages) {
            let match = true;
            let minIndex = 0;
            for (let term of terms) {
              let termIndex = name.indexOf(term);
              if (termIndex < minIndex) {
                match = false;
                break;
              }
              minIndex = termIndex;
            }

            if (match) {
              show.push(this.cardImages[name]);
            }
          }

          return show;
        }
      },
      watch: {
        query(to) {
          if (this.fromLocation) {
            return;
          }
          window.history.pushState('', '', to ? `?q=${encodeURIComponent(to)}` : '?');
        }
      }
    });
  </script>
</body>
</html>
